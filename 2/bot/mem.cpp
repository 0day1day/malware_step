#include "mem.h"


void * __cdecl malloc(_In_ size_t _Size){
	return HeapAlloc(GetProcessHeap(), 0, _Size);
}

void free(void *p){
	HeapFree(GetProcessHeap(), 0, p);
}

void * __cdecl realloc(_Post_ptr_invalid_ void * _Memory, _In_ size_t _NewSize){
	return HeapReAlloc(GetProcessHeap(), 0, _Memory, _NewSize);
}


cmem::cmem(void *data,int size){
	if (!data || !size)
		return;
	this->data=0;
	this->size=0;
	push(data,size);	
}

void cmem::free(){
	if (size){
		::free(data);
		data=0;
		size=0;
	}
}
void cmem::operator =(cmem &w){
	free();
	this->data=(BYTE*)malloc(w.size);
	this->size=w.size;
	memcpy(this->data,w.data,w.size);
}

bool cmem::push(cmem &v){
	return push(v.data,v.size);
}

void cmem::alloc(DWORD sized)
{
	if (!sized)	return;
	free();
	this->data=(BYTE*)::malloc(sized);
	this->size=sized;
}


cmem cmem::operator+(cmem &v){
	cmem a;
	a.push(*this);
	a.push(v);
	return a;
}

cmem::cmem(const cmem & w){
	free();
	this->data=(BYTE*)malloc(w.size);
	this->size=w.size;
	memcpy(this->data,w.data,w.size);
}

bool cmem::realloc(int size){
	bool r=true;
	if (!size){
		free();
		return r;
	}

	if (this->size>0){
		this->data=(BYTE*)::realloc(data,size);
		this->size=size;
	}else{
		data=(BYTE*)::malloc(size);
		this->size=size;
	}
	
	if (!data){
		r=false;
		this->size=0;
	}
	return r;
}

bool cmem::push(void *p,int size){
	bool r=false;
	if (!size)
		return r;
	if (!realloc(this->size+size))
		return r;
	memcpy(&data[this->size-size],p,size);
	r=true;
	return r;
}


bool cmem::push(LPSTR p)
{
	return push(p,lstrlenA(p));
}

bool cmem::push(LPWSTR p)
{
	return push(p,lstrlenW(p)*2);
}


bool cmem::push(DWORD v){
	if (!push(&v, 4))
		return false;
	return true;
}

bool cmem::push(uint64 v){
	if (!push(&v, 8))
		return false;
	return true;
}

bool cmem::push(WORD v){
	if (!push(&v, 2))
		return false;
	return true;
}

bool cmem::push(BYTE v){
	if (!push(&v, 1))
		return false;
	return true;
}


cmem::cmem(){
	data=0;
	size=0;
}

cmem::~cmem(){
	free();
}

bool cmem::pop(size_t size)
{
	if (this->size < size)
		return false;
	memcpy(data, &data[size],this->size-size);
	if (!realloc(this->size - size))
		return false;
	return true;
}

bool cmem::pop(void *in, DWORD size){
	if (this->size < size)
		return false;
	memcpy(in, data, size);
	memcpy(data, &data[size],this->size-size);
	if (!realloc(this->size - size))
		return false;
	return true;
}

bool cmem::pop(cmem &in, DWORD size){
	if (!in.realloc(size))
		return false;
	if (!in.pop(in.data, size))
		return false;
	return true;
}

bool cmem::pop(DWORD &v){
	if (!pop(&v, 4))
		return false;
	return true;
}

bool cmem::pop(WORD &v){
	if (!pop(&v, 2))
		return false;
	return true;
}

bool cmem::pop(BYTE &v){
	if (!pop(&v, 1))
		return false;
	return true;
}

bool cmem::pop(uint64 &v){
	if (!pop(&v, 8))
		return false;
	return true;
}
